<!DOCTYPE>
<html>
<head>
<title>Sky Hopper - Web Application for Sky Navigation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>
<style>
body { font-size: 5mm ; color:red ; font-family: sans }
button { height:10mm; font-size:5mm ; text-align:center; background-color:black; color:red; border: 2px solid red }
.comp_but, .incdec_but { width: 10mm ; height:10mm; font-size:5mm }
.comp_but { float:right }
</style>
<body>
<canvas style="position:absolute; left:0; top:0; z-index:-1"  id="myCanvas" width="640" height="480"> </canvas>
<p>
		<button class="incdec_but" onclick="decFOV();">-</button>
		<button class="incdec_but" onclick="incFOV();">+</button>
		&angle;<span id="fov_val">60&deg;</span><span style="font-size:16px" id="rtime"></span>
		<span style="float:right">
			<button class="incdec_but" id="night_mode" onclick="switchMode();">N</button>
			<button class="incdec_but" onclick="resetAll();">&#x21bb;</button>
		</span>
</p>
<p>
		<button class="incdec_but" onclick="decMAG();">-</button>
		<button class="incdec_but" onclick="incMAG();">+</button>
		<i>m&leq;</i><span id="mag_val">4</span>
		<button id="req_fs" class="incdec_but" style="float:right" onclick="toggleFS();">&#x2725;</button>
</p>
<p>
	<button class="ui_but" onclick="align();">Align</button>
	<span id="alignment"></span>
	<button class="comp_but" id="nocompass_button" style="display:none"><strike>&#x238b;</strike></button>
	<button class="comp_but" id="hand_button" style="display:none; color: transparent; text-shadow: 0 0 0 red;" onclick="manualMode();">&#x270B;</button>
	<button class="comp_but" id="compass_button" style="display:none" onclick="compassMode();">&#x238b;</button>
</p>
<p>
</p>
<p id="orient"></p>
<p id="orientN"></p>
<script src='jsdb.js' ></script>
<script>

var global_day_style = {
	cross 		: 'blue',
	constelations 	: 'yellow',
	bearing 	: 'green',
	star		: 'white',
	altaz		: 'red',
	target		: 'cyan',
	align		: 'magenta'
};

var global_night_style = {
	cross 		: 'red',
	constelations 	: '#880000',
	bearing 	: 'red',
	star		: 'red',
	altaz		: 'red',
	target		: '#AA0000',
	align		: '#AA0000'
};



var global_style = global_day_style;

var global_targets_list = [];
var global_prev_xy=null;
var global_target_index = -1;
var global_align_index = -1;
var global_expecting_select = null;
var global_camera_projection = true;
var global_expected_frame_rate_ms = 66;
var global_use_compass = false;

var global_fov = 60;
var global_mag = 4;
var gdata = {
	"lat" : 31.9,
	"lon" : 34.8,
	"compass_alpha" : 0,
	"alpha" : 0,
	"alpha_user_offset" : 0,
	"alpha_gyro" : 0,
	"alpha_diff" : 0,
	"beta" : 0,
	"gamma" : 0,
	"time" : Date.now(), //1614716453109
}

var global_align_matrix = [1,0,0,0,1,0,0,0,1];
var global_use_gyro = false;
var global_full_screen = false;

function toggleFS()
{
	var fs = document.getElementById('req_fs');
	if(!global_full_screen) {
		document.documentElement.requestFullscreen({navigationUI:'hide'});
		fs.innerHTML = '&#x2193';
		global_full_screen = true;
	}
	else {
		document.exitFullscreen();
		fs.innerHTML = '&#x2725;'
		global_full_screen = false;
	}
}

function incMAG()
{
	if(global_mag < 6)
		global_mag += 1;
	updateMAG()
}
function decMAG()
{
	if(global_mag > 1)
		global_mag -=1;
	updateMAG();
}
function updateMAG()
{
	document.getElementById("mag_val").innerHTML = global_mag + "";
}

function incFOV()
{
	if(global_fov < 150)
		global_fov += 30;
	updateFOV()
}
function decFOV()
{
	if(global_fov > 30)
		global_fov -=30;
	updateFOV();
}
function updateFOV()
{
	document.getElementById("fov_val").innerHTML = global_fov + "&deg;";
}

function setUseGyro(val,message=null)
{
	global_use_gyro = val;
	if(message)
		var status = message;
	else
		var status= global_use_gyro ? "Aligned" : "Not Aligned";
	document.getElementById("alignment").innerHTML = status
}

function resetAll()
{
	global_expecting_select = null;
	global_target_index = -1;
	global_align_index = -1;
	setUseGyro(false);
}

function align()
{
	setUseGyro(false,"Select Star");
	global_align_index = -1;
	global_expecting_select = selectAlign;
}

function normV(v)
{
	var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
	return [v[0]/len,v[1]/len,v[2]/len];
}

function matMul(A,B)
{
	var v1 = mvec(A,[B[0],B[3],B[6]]);
	var v2 = mvec(A,[B[1],B[4],B[7]]);
	var v3 = mvec(A,[B[2],B[5],B[8]]);
	return [v1[0],v2[0],v3[0],
		v1[1],v2[1],v3[1],
		v1[2],v2[2],v3[2]];
}

function matAdd(A,alpha,B,beta)
{
	var res = [];
	for(var i=0;i<9;i++) {
		res.push(A[i]*alpha + B[i]*beta);
	}
	return res;
}

function matEye()
{
	return [1,0,0, 0,1,0, 0,0,1];
}

function selectAlign(index)
{
	var camRays =  getCameraRays();
	var st = allstars[index];
	var tr = rayFromPos(st.RA,st.DE);
	var fw = camRays[2];
	var left = camRays[1];
	var dAZ = Math.asin(crossProd(normV([tr[0],tr[1],0]),normV([fw[0],fw[1],0]))[2]);
	var dAlt = Math.asin(tr[2]) - Math.asin(fw[2]);
	// rotate around AZ axis
	var daz_mat =  [  Math.cos(dAZ), Math.sin(dAZ), 0,
			 -Math.sin(dAZ), Math.cos(dAZ), 0,
			 0,		 0,		1];
	// rotate around up/dwn - axis of the camera
	var u0 = left[0];
	var u1 = left[1];
	var u2 = left[2];
	var W = [ 0, -u2, u1,   u2, 0, -u0,  -u1, u0, 0 ]
	var dalt_mat = matAdd(matEye(),1,W,Math.sin(-dAlt));
	dalt_mat = matAdd(dalt_mat,1,matMul(W,W),2*Math.sin(-dAlt/2)*Math.sin(-dAlt/2));
	
	//global_align_matrix = daz_mat;
	global_align_matrix = matMul(daz_mat,dalt_mat); 
	
	setUseGyro(true);
	gdata.alpha_diff = (gdata.alpha + gdata.alpha_user_offset) - gdata.alpha_gyro;
	global_align_index = index;
	global_expecting_select = selectTaret;
}

/// rotation matrix is 
/// taken from https://www.w3.org/TR/2016/CR-orientation-event-20160818/#worked-example-2

var degtorad = Math.PI / 180; // Degree-to-Radian conversion


function getRotationMatrix( alpha, beta, gamma ) {

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x );
  var cY = Math.cos( _y );
  var cZ = Math.cos( _z );
  var sX = Math.sin( _x );
  var sY = Math.sin( _y );
  var sZ = Math.sin( _z );

  //
  // ZXY rotation matrix construction.
  //

  var m11 = cZ * cY - sZ * sX * sY;
  var m12 = - cX * sZ;
  var m13 = cY * sZ * sX + cZ * sY;

  var m21 = cY * sZ + cZ * sX * sY;
  var m22 = cZ * cX;
  var m23 = sZ * sY - cZ * cY * sX;

  var m31 = - cX * sY;
  var m32 = sX;
  var m33 = cX * cY;

  return [
    m11,    m12,    m13,
    m21,    m22,    m23,
    m31,    m32,    m33
  ];

};

function mvec(m,v)
{
	return [ m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
		 m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
		 m[6] * v[0] + m[7] * v[1] + m[8] * v[2] ];
}

function crossProd(a,b)
{
	return [ a[1]*b[2] - a[2]*b[1],
		 a[2]*b[0] - a[0]*b[2],
		 a[0]*b[1] - a[1]*b[0] ];
}

function getCameraRays()
{
	// zxy
	// after Mul comonents are [S,E,D]
	var alpha = global_use_gyro ? gdata.alpha_gyro + gdata.alpha_diff : gdata.alpha + gdata.alpha_user_offset;
	var M = getRotationMatrix(alpha,gdata.beta,gdata.gamma);
	//var top = mvec(M,[1,0,0]);
	//var lft = mvec(M,[0,1,0]);
	//var fwd = mvec(M,[0,0,-1]);
	
	

	var fwd = mvec(M,[0,1,0]);

	// make sure left  is horizontal

	var fwd_hlen = Math.sqrt(fwd[0]*fwd[0] + fwd[1]*fwd[1])
	var fwd_hor = [fwd[0]/fwd_hlen,fwd[1]/fwd_hlen,0.0];

	var lft = [-fwd_hor[1],fwd_hor[0],0.0]
	var top = crossProd(fwd,lft);

	if(global_use_gyro) {
		return [
			mvec(global_align_matrix,top),
			mvec(global_align_matrix,lft),
			mvec(global_align_matrix,fwd)
		];
	}
	else {
		return [top,lft,fwd];
	}
}

function rayFromPos(RAd,DEd)
{
	var deg2rad = Math.PI / 180;
	RA = RAd * deg2rad;
	DE = DEd * deg2rad;
	var jd = gdata.time * 1e-3 / 86400.0 + 2440587.5;
	var tu = jd - 2451545.0;
	var angle = Math.PI * 2 * (0.7790572732640+1.00273781191135448 * tu);
	var q = angle + gdata.lon*deg2rad;
	var H = q - RA;
	var f = deg2rad * gdata.lat;

	var az_y = Math.sin(H);
	var az_x = (Math.cos(H) * Math.sin(f) - Math.tan(DE) * Math.cos(f));
	var az = Math.atan2(az_y,az_x)
	var sinH = Math.sin(f) * Math.sin(DE) + Math.cos(f) * Math.cos(DE) * Math.cos(H);
	var hz = Math.asin(sinH)
	var ray_n = -Math.cos(az) * Math.cos(hz);
	var ray_e = -Math.sin(az) * Math.cos(hz);
	var ray_u = Math.sin(hz);
	return [ ray_e, ray_n, ray_u ];
}

function sprod(v1,v2)
{
	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

function cameraBearing(RAd,DEd,cameraRays)
{
	var ray = rayFromPos(RAd,DEd);
	var top = cameraRays[0];
	var lft = cameraRays[1];
	var fwd = cameraRays[2];
	var x = -sprod(lft,ray);
	var y = sprod(top,ray);
	var z = sprod(fwd,ray);
	return {"x":x,"y":y,"z":z};
}

function getFOV()
{
	var ratio = canvas.width / canvas.height;
	var fov_td,fov_lr;
	if(ratio < 1) {
		fov_td = global_fov;
		fov_lr = fov_td * ratio;
	}
	else {
		fov_lr = global_fov;
		fov_td = fov_lr / ratio;
	}
	return {"lr":fov_lr,"td":fov_td};
}


function xyzTo2d(xyz,in_fov=true)
{
	var deg2rad = Math.PI / 180;
	var fov = getFOV();
	var fov_td = fov.td * deg2rad / 2;
	var fov_lr = fov.lr * deg2rad / 2;
	var x=xyz.x; var y=xyz.y;  var z=xyz.z;

	if(z<=0)
		return null;
	if(global_camera_projection) {
		var lim_x = Math.sin(fov_lr);
		var lim_y = Math.sin(fov_td);
	}
	else {
		x = Math.asin(x);
		y = Math.asin(y)
		var lim_x = fov_lr;
		var lim_y = fov_td;

	}
	if(in_fov) {
		if(x < -lim_x || x > lim_x)
			return null;
		if(y < -lim_y || y > lim_y)
			return null;
	}
	return { x:(x + lim_x) / (lim_x*2), y: 1 - (y + lim_y) / (lim_y * 2) };
}
function projectToCamera(RAd,DEd,cameraRays,in_fov=true)
{
	var xyz = cameraBearing(RAd,DEd,cameraRays)
	return xyzTo2d(xyz,in_fov);
}

function plotStar(star,camRays,highlight)
{
	if(canvas.width != document.body.clientWidth || canvas.height != document.body.clientHeight) {
		canvas.width = document.body.clientWidth;
		canvas.height = document.body.clientHeight;
	}
	
	var pos = projectToCamera(star.RA,star.DE,camRays);
	if(!pos)
		return null;
	context.beginPath();	
	var size = 6.5 - star.AM;
	if(size < 1)
		size = 1;
	var color;
	if(highlight) {
		color = highlight;
		size = 10;
	}
	else {
		color = global_style.star;
	}
	if(star.t == 'S')
		context.fillStyle = color;
	else
		context.fillStyle = 'black';
	var pix_x = pos.x * canvas.width;
	var pix_y = pos.y * canvas.height;
	if(star.t != 'Ca') {
		context.strokeStyle = color;
		context.lineWidth = 1;
		context.arc(pix_x,pix_y,size,0,2*Math.PI,false);
		context.fill();
		context.stroke();
	}
	if(star.name) {
		if(star.t == 'Ca') {
			color = global_style.constelations;
		}
		context.strokeStyle = color;
		context.fillStyle = color;
		if(star.t == 'Ca') {
			context.font = "4mm Sans"
			context.textBaseline = 'middle';
			context.textAlign = 'center';
			context.fillText(star.name,pix_x,pix_y)
		}
		else {
			context.font = "3mm Sans";
			context.textBaseline = 'bottom';
			context.textAlign = 'start';
			context.fillText(star.name,pix_x + size + 1,pix_y - size - 1)
		}
	}
	return { x: pix_x, y:pix_y , index:-1};
}

function plotLines(camRays)
{
	for(var i=0;i<constellation_lines.length;i++) {
		line = constellation_lines[i];
		var p1 = projectToCamera(line.r0,line.d0,camRays,false);
		var p2 = projectToCamera(line.r1,line.d1,camRays,false);
		if(!p1 || !p2)
			continue;
		context.beginPath();	
		context.strokeStyle = global_style.constelations;
		context.lineWidth = 1;
		context.moveTo(p1.x*canvas.width,p1.y*canvas.height);
		context.lineTo(p2.x*canvas.width,p2.y*canvas.height);
		context.stroke();
	}
}


function plotCross()
{
	context.strokeStyle = global_style.cross;
	context.fillStyle = global_style.cross;
	context.lineWidth = 3;
	var dirs = [[1,0],[0,1],[-1,0],[0,-1]];
	var length = 50;
	var offset =10;
	for(var i=0;i<dirs.length;i++) {
		context.moveTo(canvas.width/2 + offset*dirs[i][0],canvas.height/2 + offset*dirs[i][1]);
		context.lineTo(canvas.width/2 + length*dirs[i][0],canvas.height/2 + length*dirs[i][1]);
	}
	context.stroke();
}

function plotBearing(xyz)
{
	context.beginPath();
	context.strokeStyle = global_style.bearing;
	context.fillStyle = global_style.bearing;
	context.lineWidth = 5;
	context.arc(canvas.width/2,canvas.height/2,10,0,2*Math.PI,false);
	context.moveTo(canvas.width/2,canvas.height/2);
	var dx = xyz.x;
	var dy = -xyz.y;
	var r = 1 / Math.sqrt(dx*dx+dy*dy);
	dx = dx*r;
	dy = dy*r;
	var length = 100;
	var pos = xyzTo2d(xyz);
	if(pos) {
		var px = canvas.width * (pos.x - 0.5); 
		var py = canvas.height * (pos.y - 0.5);
		var dist = Math.sqrt(px*px + py*py);
		if(dist < length)
			length = dist;
	}
	context.lineTo(canvas.width/2 + dx * length,canvas.height/2 + dy * length);
	var updn = (dy > 0 ? 'Down' : 'Up' ) + ' ' + Math.abs(Math.atan2(-xyz.y,xyz.z) / Math.PI * 180).toFixed(1) + '\u00b0';
	var left = (dx > 0 ? 'Right' : 'Left' ) + ' ' + Math.abs(Math.atan2(xyz.x,xyz.z) / Math.PI * 180).toFixed(1) + '\u00b0';
	context.stroke();
	context.lineWidth = 0;
	context.font = "6mm Serif";
	context.strokeStyle = global_style.bearing;
	context.fillStyle = global_style.bearing;
	context.textBaseline = 'middle';
	context.textAlign = 'end';
	context.fillText(updn,canvas.width - 5,canvas.height / 2)
	context.textAlign = 'center';
	context.textBaseline = 'bottom';
	context.fillText(left,canvas.width/2,canvas.height - 5)
}			




function plotStars()
{
	var start=Date.now();
	global_targets_list=[];
	gdata.time = Date.now();
	var camRays = getCameraRays();
	context.fillStyle = "black";
	context.fillRect(0, 0, canvas.width, canvas.height);
	context.fillStyle = global_style.star;


	for(var i=0;i<allstars.length;i++) {
		if(allstars[i].AM > global_mag)
			break;
		var highlight = null;
		if(i == global_target_index)
			highlight = global_style.target;
		else if(i == global_align_index)
			highlight = global_style.align;
		var  pos = plotStar(allstars[i],camRays,highlight);
		// select only stars if not aligned
		// if aligned select all but constellations
		if(pos && allstars[i].t!='Ca' && (allstars[i].t == 'S' || global_use_gyro)) {
			pos.index = i;
			global_targets_list.push(pos);
		}
	}
	if(global_target_index >= 0) {
		var star = allstars[global_target_index];
		var xyz = cameraBearing(star.RA,star.DE,camRays);
		plotBearing(xyz);

	}
	else if(global_use_gyro) {
		plotCross();
	}
	plotLines(camRays);
	plotAltAz(camRays[2]);
	var passed = Date.now() - start;
	if(passed > global_expected_frame_rate_ms / 2) {
		setTimeout(plotStars,global_expected_frame_rate_ms);
	}
	else {
		setTimeout(plotStars,global_expected_frame_rate_ms-passed);
	}
}

function plotAltAz(fwd)
{
	var alt = Math.asin(fwd[2]) / Math.PI * 180;
	var az  = Math.atan2(fwd[0],fwd[1]) / Math.PI * 180;
	alt = 'Alt:' + alt.toFixed(1);
	if(az < 0)
		az = 360 + az;
	az  = 'Az:' + az.toFixed(1);
	context.font = "5mm Sans"
	context.textBaseline = 'bottom';
	context.textAlign = 'end';
	context.fillStyle = global_style.altaz;
	context.fillText(alt,canvas.width - 5,canvas.height - 5)
	context.textAlign = 'start';
	context.fillText(az,5,canvas.height - 5)
}

function selectTaret(index)
{
	global_target_index = index;
	//global_expecting_select = null;
}

function selectionEvent(e)
{
	let x = e.clientX;
	let y = e.clientY;
	let min_dist = 1e100;
	let min_index = -1;
	for(var i=0;i<global_targets_list.length;i++) {
		let dx = global_targets_list[i].x - x;
		let dy = global_targets_list[i].y - y;
		let dist = dx*dx + dy*dy;
		if(min_dist > dist) {
			min_dist = dist;
			min_index = global_targets_list[i].index;
		}
	}
	if(global_expecting_select) {
		global_expecting_select(min_index);
	}
}

function showpos(position)
{
	var latlon = position.coords.latitude + "," + position.coords.longitude;
	gdata.lat = position.coords.latitude;
	gdata.lon = position.coords.longitude;
}

function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showpos);
  }
}

function gyroListener(event)
{
	gdata.alpha_gyro = event.alpha;
}


function deviceOrientationListener(event) {
	if(!(event.alpha === null)) {
		if(global_use_compass)
			gdata.alpha = event.alpha;
		gdata.compass_alpha = event.alpha;
		gdata.beta = event.beta;
		gdata.gamma = event.gamma;
	}
}


function noCompass()
{
	document.getElementById("nocompass_button").style.display="inline";
	document.getElementById("compass_button").style.display="none";
	document.getElementById("hand_button").style.display="none";
}

function manualMode()
{
	global_use_compass = false;
	gdata.alpha_user_offset = gdata.alpha;
	gdata.alpha = 0;
	document.getElementById("compass_button").style.display="inline";
	document.getElementById("hand_button").style.display="none";
}

function compassMode()
{
	global_use_compass = true;
	gdata.alpha_user_offset = 0;
	gdata.alpha = gdata.compass_alpha;
	document.getElementById("compass_button").style.display="none";
	document.getElementById("hand_button").style.display="inline";
}

function manualDown(e)
{
	global_prev_xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
}

function manualMove(e)
{
	if(!global_prev_xy)
		return;
	
	var xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
	moveSky(global_prev_xy,xy);
	global_prev_xy = xy;
}
function manualUp(e)
{
	if(!global_prev_xy)
		return;
	var xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
	moveSky(global_prev_xy,xy);
	global_prev_xy = null;
}
function moveSky(prev,cur)
{
	if(global_use_compass)
		return;
	if(!prev || !cur)
		return;
	var fov =  getFOV().lr;
	var da = (cur.x - prev.x) / canvas.width * fov;;
	gdata.alpha_user_offset += da;
}

function dontPropMouseDown(lst)
{
	for(var i=0;i<lst.length;i++) {
		var elements = document.getElementsByClassName(lst[i]);
		for(var j=0;j<elements.length;j++) {
			elements[j].addEventListener('mousedown',function(e) {
				e.stopPropagation();
			});
		}
	}
}

function setupOrientationEvents()
{
	if (window.DeviceOrientationEvent) {
		if(('ondeviceorientationabsolute' in window)) {
			window.addEventListener("deviceorientationabsolute", deviceOrientationListener);
			window.addEventListener("deviceorientation",gyroListener);
			compassMode();
		}
		else if(('ondeviceorientation' in window)) {
			global_use_compass = false;
			window.addEventListener("deviceorientation", deviceOrientationListener);
			window.addEventListener("deviceorientation",gyroListener);
			noCompass();
		}
		else {
			unsupported();
		}
	} else {
		unsupported();
	}
	setUseGyro(false);
}
function switchMode()
{
	var el = document.getElementById('night_mode');
	if(global_style == global_day_style) {
		global_style = global_night_style;
		el.innerHTML = 'D';
	}
	else {
		global_style = global_day_style;
		el.innerHTML = 'N';
	}
}

setupOrientationEvents();
// global drawing stuff
var canvas = document.getElementById('myCanvas');
canvas.width = document.body.clientWidth;
canvas.height = document.body.clientHeight;
var context = canvas.getContext('2d');
setTimeout(getLocation,500)
setTimeout(plotStars,1000)
document.body.addEventListener('mousedown',selectionEvent);
document.body.addEventListener('touchstart',manualDown);
document.body.addEventListener('touchend',manualUp);
document.body.addEventListener('touchcancel',manualUp);
document.body.addEventListener('touchmove',manualMove);
dontPropMouseDown(["ui_but","incdec_but"]);
</script>


</body>
</html>
